/**
 * Generated {{entityName}}Repository - Mongoose Implementation
 * 
 * Generated on: {{timestamp}}
 * ORM: {{ormType}}
 * 
 * This file was auto-generated by @kenniy/godeye-data-contracts
 * Do not modify this file directly. Regenerate using:
 * npx godeye-generate repository {{entityName}}
 */

import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Document, FilterQuery, UpdateQuery } from 'mongoose';
import { {{entityName}} } from '../models/{{entityNameKebab}}.model';
import { 
  IPaginationOptions, 
  IPaginationResult,
  ICriteria,
  IRepositoryConfig 
} from '@kenniy/godeye-data-contracts';

export interface {{entityName}}Document extends {{entityName}}, Document {}

export interface {{entityName}}Criteria extends ICriteria<{{entityName}}> {
  where?: FilterQuery<{{entityName}}Document> & {
    // Add custom search criteria here
    search?: string;
  };
  populate?: {
{{#each relations}}
    {{this}}?: boolean;
{{/each}}
  };
  select?: string | string[];
}

@Injectable()
export class {{entityName}}Repository {
  constructor(
    @InjectModel({{entityName}}.name) 
    private readonly model: Model<{{entityName}}Document>
  ) {}

  /**
   * Find single entity by criteria
   */
  async findOne(criteria: Partial<{{entityName}}Criteria>): Promise<{{entityName}}Document | null> {
    const { where, populate, select } = criteria;
    
    let query = this.model.findOne(where || {});
    
    if (populate) {
{{#each relations}}
      if (populate.{{this}}) {
        query = query.populate('{{this}}');
      }
{{/each}}
    }
    
    if (select) {
      query = query.select(select);
    }
    
    return await query.exec();
  }

  /**
   * Find multiple entities by criteria
   */
  async find(criteria: {{entityName}}Criteria = {}): Promise<{{entityName}}Document[]> {
    const { where, populate, select, sort, limit } = criteria;
    
    let query = this.model.find(where || {});
    
    if (populate) {
{{#each relations}}
      if (populate.{{this}}) {
        query = query.populate('{{this}}');
      }
{{/each}}
    }
    
    if (select) {
      query = query.select(select);
    }
    
    if (sort) {
      query = query.sort(sort);
    } else {
      query = query.sort({ createdAt: -1 });
    }
    
    if (limit) {
      query = query.limit(limit);
    }
    
    return await query.exec();
  }

  /**
   * Find with pagination - optimized for performance
   */
  async findWithPagination(
    criteria: {{entityName}}Criteria & IPaginationOptions
  ): Promise<IPaginationResult<{{entityName}}Document>> {
    const { page = 1, limit = 20, where, populate, select, sort } = criteria;
    
    // Build base filter with search functionality
    const filter = this.buildSearchFilter(where || {});
    
    // Build query
    let query = this.model.find(filter);
    
    if (populate) {
{{#each relations}}
      if (populate.{{this}}) {
        query = query.populate('{{this}}');
      }
{{/each}}
    }
    
    if (select) {
      query = query.select(select);
    }
    
    if (sort) {
      query = query.sort(sort);
    } else {
      query = query.sort({ createdAt: -1 });
    }
    
    // Apply pagination
    const skip = (page - 1) * limit;
    query = query.skip(skip).limit(limit);
    
    // Execute query and count in parallel for better performance
    const [items, total] = await Promise.all([
      query.exec(),
      this.model.countDocuments(filter)
    ]);
    
    return {
      items,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
      hasNext: page * limit < total,
      hasPrev: page > 1
    };
  }

  /**
   * Create new entity
   */
  async create(data: Partial<{{entityName}}>): Promise<{{entityName}}Document> {
    const entity = new this.model(data);
    return await entity.save();
  }

  /**
   * Update entity by ID
   */
  async updateById(id: string, data: UpdateQuery<{{entityName}}Document>): Promise<{{entityName}}Document | null> {
    return await this.model.findByIdAndUpdate(
      id, 
      data, 
      { new: true, runValidators: true }
    ).exec();
  }

  /**
   * Update multiple entities
   */
  async updateMany(
    criteria: FilterQuery<{{entityName}}Document>, 
    data: UpdateQuery<{{entityName}}Document>
  ): Promise<number> {
    const result = await this.model.updateMany(criteria, data);
    return result.modifiedCount;
  }

  /**
   * Delete entity by ID
   */
  async deleteById(id: string): Promise<boolean> {
    const result = await this.model.findByIdAndDelete(id);
    return result !== null;
  }

  /**
   * Delete multiple entities
   */
  async deleteMany(criteria: FilterQuery<{{entityName}}Document>): Promise<number> {
    const result = await this.model.deleteMany(criteria);
    return result.deletedCount || 0;
  }

  /**
   * Find by ID with populate
   */
  async findById(
    id: string, 
    populate?: (keyof {{entityName}}Criteria['populate'])[]
  ): Promise<{{entityName}}Document | null> {
    let query = this.model.findById(id);
    
    if (populate?.length) {
{{#each relations}}
      if (populate.includes('{{this}}')) {
        query = query.populate('{{this}}');
      }
{{/each}}
    }
    
    return await query.exec();
  }

  /**
   * Count entities by criteria
   */
  async count(criteria: Partial<{{entityName}}Criteria> = {}): Promise<number> {
    const filter = this.buildSearchFilter(criteria.where || {});
    return await this.model.countDocuments(filter);
  }

  /**
   * Check if entity exists
   */
  async exists(criteria: FilterQuery<{{entityName}}Document>): Promise<boolean> {
    const doc = await this.model.findOne(criteria).select('_id').lean();
    return doc !== null;
  }

  /**
   * Bulk operations for better performance
   */
  async bulkCreate(data: Partial<{{entityName}}>[]): Promise<{{entityName}}Document[]> {
    return await this.model.insertMany(data);
  }

  /**
   * Aggregation pipeline for complex queries
   */
  async aggregate(pipeline: any[]): Promise<any[]> {
    return await this.model.aggregate(pipeline);
  }

  /**
   * Aggregation with pagination
   */
  async aggregateWithPagination(
    pipeline: any[], 
    page: number = 1, 
    limit: number = 20
  ): Promise<IPaginationResult<any>> {
    const skip = (page - 1) * limit;
    
    const [result] = await this.model.aggregate([
      ...pipeline,
      {
        $facet: {
          items: [{ $skip: skip }, { $limit: limit }],
          totalCount: [{ $count: 'count' }]
        }
      }
    ]);
    
    const items = result.items || [];
    const total = result.totalCount[0]?.count || 0;
    
    return {
      items,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
      hasNext: page * limit < total,
      hasPrev: page > 1
    };
  }

  /**
   * Get distinct values for a field
   */
  async distinct(field: string, criteria: FilterQuery<{{entityName}}Document> = {}): Promise<any[]> {
    return await this.model.distinct(field, criteria);
  }

  /**
   * Build search filter with text search functionality
   */
  private buildSearchFilter(where: FilterQuery<{{entityName}}Document>): FilterQuery<{{entityName}}Document> {
    const { search, ...otherCriteria } = where as any;
    
    if (!search) {
      return otherCriteria;
    }
    
    // Create text search across multiple fields
    const searchFields = [{{#each properties}}'{{this}}'{{#unless @last}}, {{/unless}}{{/each}}];
    const searchConditions = searchFields.map(field => ({
      [field]: { $regex: search, $options: 'i' }
    }));
    
    return {
      ...otherCriteria,
      $or: searchConditions
    };
  }

  /**
   * Native Mongoose model access for advanced queries
   */
  getModel(): Model<{{entityName}}Document> {
    return this.model;
  }
}