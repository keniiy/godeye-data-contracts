/**
 * Generated {{entityName}}Repository - TypeORM Implementation
 * 
 * Generated on: {{timestamp}}
 * ORM: {{ormType}}
 * 
 * This file was auto-generated by @kenniy/godeye-data-contracts
 * Do not modify this file directly. Regenerate using:
 * npx godeye-generate repository {{entityName}}
 */

import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository as TypeORMRepository, SelectQueryBuilder } from 'typeorm';
import { {{entityName}} } from '../entities/{{entityNameKebab}}.entity';
import { 
  IPaginationOptions, 
  IPaginationResult,
  ICriteria,
  IRepositoryConfig 
} from '@kenniy/godeye-data-contracts';

export interface {{entityName}}Criteria extends ICriteria<{{entityName}}> {
  where?: Partial<{{entityName}}> & {
    // Add custom search criteria here
    search?: string;
  };
  relations?: {
{{#each relations}}
    {{this}}?: boolean;
{{/each}}
  };
  select?: (keyof {{entityName}})[];
}

@Injectable()
export class {{entityName}}Repository {
  constructor(
    @InjectRepository({{entityName}}) 
    private readonly repository: TypeORMRepository<{{entityName}}>
  ) {}

  /**
   * Find single entity by criteria
   */
  async findOne(criteria: Partial<{{entityName}}Criteria>): Promise<{{entityName}} | null> {
    const queryBuilder = this.createQueryBuilder('{{entityNameLower}}');
    
    this.applyCriteria(queryBuilder, criteria);
    
    return await queryBuilder.getOne();
  }

  /**
   * Find multiple entities by criteria
   */
  async find(criteria: {{entityName}}Criteria = {}): Promise<{{entityName}}[]> {
    const queryBuilder = this.createQueryBuilder('{{entityNameLower}}');
    
    this.applyCriteria(queryBuilder, criteria);
    
    if (criteria.limit) {
      queryBuilder.limit(criteria.limit);
    }
    
    return await queryBuilder.getMany();
  }

  /**
   * Find with pagination - optimized for performance
   */
  async findWithPagination(
    criteria: {{entityName}}Criteria & IPaginationOptions
  ): Promise<IPaginationResult<{{entityName}}>> {
    const { page = 1, limit = 20, ...searchCriteria } = criteria;
    
    const queryBuilder = this.createQueryBuilder('{{entityNameLower}}');
    
    this.applyCriteria(queryBuilder, searchCriteria);
    
    // Apply pagination
    const skip = (page - 1) * limit;
    queryBuilder.skip(skip).take(limit);
    
    // Get results and count in parallel for better performance
    const [items, total] = await queryBuilder.getManyAndCount();
    
    return {
      items,
      total,
      page,
      limit,
      totalPages: Math.ceil(total / limit),
      hasNext: page * limit < total,
      hasPrev: page > 1
    };
  }

  /**
   * Create new entity
   */
  async create(data: Partial<{{entityName}}>): Promise<{{entityName}}> {
    const entity = this.repository.create(data);
    return await this.repository.save(entity);
  }

  /**
   * Update entity by ID
   */
  async updateById(id: string, data: Partial<{{entityName}}>): Promise<{{entityName}} | null> {
    await this.repository.update(id, data);
    return await this.findById(id);
  }

  /**
   * Update multiple entities
   */
  async updateMany(
    criteria: Partial<{{entityName}}>, 
    data: Partial<{{entityName}}>
  ): Promise<number> {
    const result = await this.repository.update(criteria, data);
    return result.affected || 0;
  }

  /**
   * Delete entity by ID
   */
  async deleteById(id: string): Promise<boolean> {
    const result = await this.repository.delete(id);
    return (result.affected || 0) > 0;
  }

  /**
   * Delete multiple entities
   */
  async deleteMany(criteria: Partial<{{entityName}}>): Promise<number> {
    const result = await this.repository.delete(criteria);
    return result.affected || 0;
  }

  /**
   * Find by ID with relations
   */
  async findById(id: string, relations?: (keyof {{entityName}}Criteria['relations'])[]): Promise<{{entityName}} | null> {
    const queryBuilder = this.createQueryBuilder('{{entityNameLower}}');
    
    queryBuilder.where('{{entityNameLower}}.id = :id', { id });
    
    if (relations?.length) {
{{#each relations}}
      if (relations.includes('{{this}}')) {
        queryBuilder.leftJoinAndSelect('{{../entityNameLower}}.{{this}}', '{{this}}');
      }
{{/each}}
    }
    
    return await queryBuilder.getOne();
  }

  /**
   * Count entities by criteria
   */
  async count(criteria: Partial<{{entityName}}Criteria> = {}): Promise<number> {
    const queryBuilder = this.createQueryBuilder('{{entityNameLower}}');
    
    this.applyCriteria(queryBuilder, criteria);
    
    return await queryBuilder.getCount();
  }

  /**
   * Check if entity exists
   */
  async exists(criteria: Partial<{{entityName}}>): Promise<boolean> {
    const count = await this.repository.count({ where: criteria });
    return count > 0;
  }

  /**
   * Bulk operations for better performance
   */
  async bulkCreate(data: Partial<{{entityName}}>[]): Promise<{{entityName}}[]> {
    const entities = this.repository.create(data);
    return await this.repository.save(entities);
  }

  /**
   * Raw query builder for complex queries
   */
  createQueryBuilder(alias: string = '{{entityNameLower}}'): SelectQueryBuilder<{{entityName}}> {
    return this.repository.createQueryBuilder(alias);
  }

  /**
   * Apply search criteria to query builder
   */
  private applyCriteria(
    queryBuilder: SelectQueryBuilder<{{entityName}}>, 
    criteria: Partial<{{entityName}}Criteria>
  ): void {
    const { where, relations, select, sort } = criteria;
    
    // Apply WHERE conditions
    if (where) {
      Object.entries(where).forEach(([key, value], index) => {
        if (value !== undefined && key !== 'search') {
          const paramKey = `${key}_${index}`;
          if (index === 0) {
            queryBuilder.where(`{{entityNameLower}}.${key} = :${paramKey}`, { [paramKey]: value });
          } else {
            queryBuilder.andWhere(`{{entityNameLower}}.${key} = :${paramKey}`, { [paramKey]: value });
          }
        }
      });
      
      // Handle search functionality
      if (where.search) {
        const searchFields = [{{#each properties}}'{{this}}'{{#unless @last}}, {{/unless}}{{/each}}];
        const searchConditions = searchFields
          .map(field => `{{entityNameLower}}.${field} ILIKE :search`)
          .join(' OR ');
        
        if (searchConditions) {
          queryBuilder.andWhere(`(${searchConditions})`, { search: `%${where.search}%` });
        }
      }
    }
    
    // Apply relations/joins
    if (relations) {
{{#each relations}}
      if (relations.{{this}}) {
        queryBuilder.leftJoinAndSelect('{{../entityNameLower}}.{{this}}', '{{this}}');
      }
{{/each}}
    }
    
    // Apply field selection
    if (select?.length) {
      const selectFields = select.map(field => `{{entityNameLower}}.${String(field)}`);
      queryBuilder.select(selectFields);
    }
    
    // Apply sorting
    if (sort) {
      Object.entries(sort).forEach(([field, direction]) => {
        queryBuilder.addOrderBy(`{{entityNameLower}}.${field}`, direction as 'ASC' | 'DESC');
      });
    } else {
      // Default sorting
      queryBuilder.orderBy('{{entityNameLower}}.createdAt', 'DESC');
    }
  }
}